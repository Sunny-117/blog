import{_ as i}from"./chunks/plugin-vue_export-helper.DlAUqK2U.js";import{c as a,o as n,X as e}from"./chunks/vendor-vueuse.XPft87tp.js";const p="/blog/assets/2024-04-15-19-41-41.BIrxf5ZM.png",m=JSON.parse('{"title":"输入 npm run xxx 后发生了什么？","description":"","frontmatter":{},"headers":[],"relativePath":"fragment/npm-scripts.md","filePath":"fragment/npm-scripts.md","lastUpdated":1771466668000}'),t={name:"fragment/npm-scripts.md"};function l(r,s,h,d,k,o){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="输入-npm-run-xxx-后发生了什么" tabindex="-1">输入 npm run xxx 后发生了什么？ <a class="header-anchor" href="#输入-npm-run-xxx-后发生了什么" aria-label="Permalink to &quot;输入 npm run xxx 后发生了什么？&quot;">​</a></h1><p>在前端开发中，我们经常使用 npm run dev 来启动本地开发环境。那么，当输入完类似 npm run xxx 的命令后，到底发生了什么呢？项目又是如何被启动的？</p><p>首先我们知道，node 可以把 .js 文件当做脚本来运行，例如启动后台项目时经常会输入：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes dracula vitesse-black vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#50FA7B;--shiki-dark:#80A665;">node</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;"> app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个是直接使用全局安装的 node 命令来执行了 ./src 目录下的 app.js 文件。</p><p>而当我们使用 npm （或者 yarn）来管理项目时，会在根目录下生成一个 package.json 文件，其中的 scripts 属性，就是用于配置 npm run xxx 命令的，比如以下配置：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes dracula vitesse-black vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;">scripts</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#DBD7CACC;">: </span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">{</span></span>
<span class="line"><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#8BE9FD;--shiki-dark:#B8A965;">dev</span><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;">:</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;">vite</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">,</span></span>
<span class="line"><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#8BE9FD;--shiki-dark:#B8A965;">build</span><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;">:</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;">vite build</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">,</span></span>
<span class="line"><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#8BE9FD;--shiki-dark:#B8A965;">preview</span><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;">:</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;">vite preview</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">}</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#DBD7CACC;">,</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>再看对应的 node_modules 目录下的.bin 目录，里面有一个 vite 文件</p><p>打开 vite 文件可以看到 #!/bin/sh，表示这是一个脚本（node 可以执行）。</p><p><img src="`+p+`" alt=""></p><p>当执行 npm run dev 时，首先会去 package.json 文件中找到 script 属性的&quot;dev&quot;,然后再到 node_modules 目录下的.bin 目录中找到&quot;dev&quot;对应的&quot;vite&quot;，执行 vite（由前面可知 vite 是一个脚本，类似于前面提过的 node app.js）。 再如：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes dracula vitesse-black vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">{</span></span>
<span class="line"><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">  &quot;</span><span style="--shiki-light:#8BE9FD;--shiki-dark:#B8A965;">dev</span><span style="--shiki-light:#8BE9FE;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;">:</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#F1FA8C;--shiki-dark:#C98A7D;">./node_modules/.bin/nodemon bin/www</span><span style="--shiki-light:#E9F284;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当执行 npm run dev 时，相当于执行 &quot;./node_modules/.bin/nodemon bin/www&quot;，其中 bin/www 作为参数传入。</p><p>总之：先去 package.json 的 scripts 属性中查找 xxx1,再去./node_modules/.bin 中查找 xxx1 对应的 sss1,执行 sss1 文件）</p><h2 id="问题分析" tabindex="-1">问题分析 <a class="header-anchor" href="#问题分析" aria-label="Permalink to &quot;问题分析&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>问题 1： 为什么不直接执行 sss 而要执行 xxx 呢？</p></div><p>直接执行 sss 会报错，因为操作系统中不存在 sss 这一条指令。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>问题 2： 为什么执行 npm run xxx（或者 yarn xxx）时就能成功呢？</p></div><p>因为我们在安装依赖的时候，是通过 npm i xxx (或者 yarn ...)来执行的，例如 npm i @vue/cli-service，npm 在 安装这个依赖的时候，就会 node_modules/.bin/ 目录中创建好名为 vue-cli-service 的几个可执行文件了。</p><p>.bin 目录下的文件，是一个个的软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本，可由 node 来执行。当使用 npm run xxx 执行 sss 时，虽然没有安装 sss 的全局命令，但是 npm 会到 ./node_modules/.bin 中找到 sss 文件作为脚本来执行，则相当于执行了 ./node_modules/.bin/sss。</p><p>即： <strong>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；没有找到则从全局的 node_modules/.bin 中查找； 全局目录还是没找到，就会从 window 的 path 环境变量中查找有没有其他同名的可执行程序。</strong></p><h2 id="浅析-npm-install-机制阅读" tabindex="-1"><a href="https://juejin.cn/post/7206998548343504956" target="_blank" rel="noreferrer">浅析 npm install 机制阅读</a> <a class="header-anchor" href="#浅析-npm-install-机制阅读" aria-label="Permalink to &quot;[浅析 npm install 机制阅读](https://juejin.cn/post/7206998548343504956)&quot;">​</a></h2>`,22)]))}const F=i(t,[["render",l]]);export{m as __pageData,F as default};
