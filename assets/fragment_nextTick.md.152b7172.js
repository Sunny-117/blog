import{_ as n,o as a,c as l,a as p}from"./app.f9cf8683.js";const F=JSON.parse('{"title":"vue nextTick 实现原理，必拿下!","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么会有 nextTick 这个东西的存在?","slug":"为什么会有-nexttick-这个东西的存在","link":"#为什么会有-nexttick-这个东西的存在","children":[]},{"level":2,"title":"nextTick 的作用？","slug":"nexttick-的作用","link":"#nexttick-的作用","children":[]},{"level":2,"title":"nextTick 实现原理","slug":"nexttick-实现原理","link":"#nexttick-实现原理","children":[]},{"level":2,"title":"源码解读","slug":"源码解读","link":"#源码解读","children":[]}],"relativePath":"fragment/nextTick.md","lastUpdated":1740908463000}'),o={name:"fragment/nextTick.md"};function e(c,s,t,r,B,y){return a(),l("div",null,s[0]||(s[0]=[p(`<h1 id="vue-nexttick-实现原理-必拿下" tabindex="-1">vue nextTick 实现原理，必拿下! <a class="header-anchor" href="#vue-nexttick-实现原理-必拿下" aria-hidden="true">#</a></h1><h2 id="为什么会有-nexttick-这个东西的存在" tabindex="-1">为什么会有 nextTick 这个东西的存在? <a class="header-anchor" href="#为什么会有-nexttick-这个东西的存在" aria-hidden="true">#</a></h2><p>因为 vue 采用的 异步更新策略 ，当监听到数据发生变化的时候不会立即去更新 DOM，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更。</p><p>这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作 DOM 的次数，如果不采用这种方法，假设数据改变 100 次就要去更新 100 次 DOM，而频繁的 DOM 更新是很耗性能的。</p><h2 id="nexttick-的作用" tabindex="-1">nextTick 的作用？ <a class="header-anchor" href="#nexttick-的作用" aria-hidden="true">#</a></h2><p>nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到 DOM 更新后才执行；想要操作 基于最新数据生成的 DOM 时，就将这个操作放在 nextTick 的回调中；</p><h2 id="nexttick-实现原理" tabindex="-1">nextTick 实现原理 <a class="header-anchor" href="#nexttick-实现原理" aria-hidden="true">#</a></h2><p>将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务； nextTick 提供了四种异步方法 Promise.then、MutationObserver、setImmediate、setTimeout(fn,0)</p><h2 id="源码解读" tabindex="-1">源码解读 <a class="header-anchor" href="#源码解读" aria-hidden="true">#</a></h2><p>源码位置 <code>core/util/next-tick</code></p><p>源码并不复杂，三个函数，60 几行代码，沉下心去看！</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">noop</span><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;shared/util&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">handleError</span><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;./error&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">import</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">isIE</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">isIOS</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">isNative</span><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;./env&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//  noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//  handleError 错误处理函数</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//  isIE, isIOS, isNative 环境判断函数，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//  isNative 判断某个属性或方法是否原生支持，如果不支持或通过第三方实现支持都会返回 false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">isUsingMicroTask</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 标记 nextTick 最终是否以微任务执行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">callbacks</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> []; </span><span style="color:#7F848E;font-style:italic;">// 存放调用 nextTick 时传入的回调函数</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">pending</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 标记是否已经向任务队列中添加了一个任务，如果已经添加了就不能再添加了</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 当向任务队列中添加了任务时，将 pending 置为 true，当任务被执行时将 pending 置为 false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 回调的 this 自动绑定到调用它的实例上</span></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">nextTick</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">cb</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">Function</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">ctx</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">_resolve</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 将传入的回调函数存放到数组中，后面会遍历执行其中的回调</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">callbacks</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(() </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">cb</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#7F848E;font-style:italic;">// 对传入的回调进行 try catch 错误捕获</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#C678DD;">try</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">cb</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">call</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ctx</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      } </span><span style="color:#C678DD;">catch</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">e</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">// 进行统一的错误处理</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#61AFEF;">handleError</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">e</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">ctx</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;nextTick&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      }</span></span>
<span class="line"><span style="color:#ABB2BF;">    } </span><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">_resolve</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">_resolve</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ctx</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 如果当前没有在 pending 的回调，</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 就执行 timeFunc 函数选择当前环境优先支持的异步方法</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">pending</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">pending</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">timerFunc</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 在返回的这个 promise.then 中 DOM 已经更新好了，</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">cb</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">typeof</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Promise</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">!==</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;undefined&quot;</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Promise</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;font-style:italic;">resolve</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#E06C75;">_resolve</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">resolve</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    });</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 判断当前环境优先支持的异步方法，优先选择微任务</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// setTimeout 可能产生一个 4ms 的延迟，而 setImmediate 会在主线程执行完后立刻执行</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// setImmediate 在 IE10 和 node 中支持</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 当在同一轮事件循环中多次调用 nextTick 时 ,timerFunc 只会执行一次</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">timerFunc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 判断当前环境是否原生支持 promise</span></span>
<span class="line"><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">typeof</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Promise</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">!==</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;undefined&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">isNative</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Promise</span><span style="color:#ABB2BF;">)) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 支持 promise</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">p</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Promise</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">resolve</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">timerFunc</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 用 promise.then 把 flushCallbacks 函数包裹成一个异步微任务</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">then</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">flushCallbacks</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">isIOS</span><span style="color:#ABB2BF;">) </span><span style="color:#61AFEF;">setTimeout</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">noop</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 标记当前 nextTick 使用的微任务</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">isUsingMicroTask</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 如果不支持 promise，就判断是否支持 MutationObserver</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务</span></span>
<span class="line"><span style="color:#ABB2BF;">} </span><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">isIE</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">typeof</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">MutationObserver</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">!==</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;undefined&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;</span></span>
<span class="line"><span style="color:#ABB2BF;">  (</span><span style="color:#61AFEF;">isNative</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">MutationObserver</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">||</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">MutationObserver</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">toString</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">===</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;[object MutationObserverConstructor]&quot;</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">counter</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// new 一个 MutationObserver 类</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">observer</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">MutationObserver</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">flushCallbacks</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 创建一个文本节点</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">textNode</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">document</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">createTextNode</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">String</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">counter</span><span style="color:#ABB2BF;">));</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 监听这个文本节点，当数据发生变化就执行 flushCallbacks</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">observer</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">observe</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">textNode</span><span style="color:#ABB2BF;">, { </span><span style="color:#E06C75;">characterData</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;"> });</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">timerFunc</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">counter</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">counter</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">%</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">textNode</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">data</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">String</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">counter</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 数据更新</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">isUsingMicroTask</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 标记当前 nextTick 使用的微任务</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 判断当前环境是否原生支持 setImmediate</span></span>
<span class="line"><span style="color:#ABB2BF;">} </span><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">typeof</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">setImmediate</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">!==</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;undefined&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">isNative</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">setImmediate</span><span style="color:#ABB2BF;">)) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">timerFunc</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">setImmediate</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">flushCallbacks</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">} </span><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 以上三种都不支持就选择 setTimeout</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">timerFunc</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">setTimeout</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">flushCallbacks</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 如果多次调用 nextTick，会依次执行上面的方法，将 nextTick 的回调放在 callbacks 数组中</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 最后通过 flushCallbacks 函数遍历 callbacks 数组的拷贝并执行其中的回调</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">flushCallbacks</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">pending</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">copies</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">callbacks</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">slice</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 拷贝一份 callbacks</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">callbacks</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 清空 callbacks</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">copies</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 遍历执行传入的回调</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">copies</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">]();</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 为什么要拷贝一份 callbacks</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 用 callbacks.slice(0) 将 callbacks 拷贝出来一份，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 是因为考虑到在 nextTick 回调中可能还会调用 nextTick 的情况,</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 如果在 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 而 nextTick 回调中的 nextTick 应该放在下一轮执行，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 否则就可能出现一直循环的情况，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 所以需要将 callbacks 复制一份出来然后清空，再遍历备份列表执行回调</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#B392F0;"> { noop } </span><span style="color:#F97583;">from</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;shared/util&quot;</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#B392F0;"> { handleError } </span><span style="color:#F97583;">from</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;./error&quot;</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#B392F0;"> { isIE</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> isIOS</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> isNative } </span><span style="color:#F97583;">from</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;./env&quot;</span><span style="color:#B392F0;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">//  noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错</span></span>
<span class="line"><span style="color:#6B737C;">//  handleError 错误处理函数</span></span>
<span class="line"><span style="color:#6B737C;">//  isIE, isIOS, isNative 环境判断函数，</span></span>
<span class="line"><span style="color:#6B737C;">//  isNative 判断某个属性或方法是否原生支持，如果不支持或通过第三方实现支持都会返回 false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">false</span><span style="color:#B392F0;">; </span><span style="color:#6B737C;">// 标记 nextTick 最终是否以微任务执行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">callbacks</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> []; </span><span style="color:#6B737C;">// 存放调用 nextTick 时传入的回调函数</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> pending </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">false</span><span style="color:#B392F0;">; </span><span style="color:#6B737C;">// 标记是否已经向任务队列中添加了一个任务，如果已经添加了就不能再添加了</span></span>
<span class="line"><span style="color:#6B737C;">// 当向任务队列中添加了任务时，将 pending 置为 true，当任务被执行时将 pending 置为 false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数</span></span>
<span class="line"><span style="color:#6B737C;">// 回调的 this 自动绑定到调用它的实例上</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">function</span><span style="color:#B392F0;"> nextTick(cb</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> Function</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> ctx</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> Object) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> _resolve;</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 将传入的回调函数存放到数组中，后面会遍历执行其中的回调</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">callbacks</span><span style="color:#B392F0;">.push(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (cb) {</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#6B737C;">// 对传入的回调进行 try catch 错误捕获</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#F97583;">try</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">cb</span><span style="color:#B392F0;">.call(ctx);</span></span>
<span class="line"><span style="color:#B392F0;">      } </span><span style="color:#F97583;">catch</span><span style="color:#B392F0;"> (e) {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#6B737C;">// 进行统一的错误处理</span></span>
<span class="line"><span style="color:#B392F0;">        handleError(e</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> ctx</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;nextTick&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span></span>
<span class="line"><span style="color:#B392F0;">    } </span><span style="color:#F97583;">else</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (_resolve) {</span></span>
<span class="line"><span style="color:#B392F0;">      _resolve(ctx);</span></span>
<span class="line"><span style="color:#B392F0;">    }</span></span>
<span class="line"><span style="color:#B392F0;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 如果当前没有在 pending 的回调，</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 就执行 timeFunc 函数选择当前环境优先支持的异步方法</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">pending) {</span></span>
<span class="line"><span style="color:#B392F0;">    pending </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    timerFunc();</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 在返回的这个 promise.then 中 DOM 已经更新好了，</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">cb </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">typeof</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">!==</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;undefined&quot;</span><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#B392F0;">((resolve) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">      _resolve </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> resolve;</span></span>
<span class="line"><span style="color:#B392F0;">    });</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 判断当前环境优先支持的异步方法，优先选择微任务</span></span>
<span class="line"><span style="color:#6B737C;">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span></span>
<span class="line"><span style="color:#6B737C;">// setTimeout 可能产生一个 4ms 的延迟，而 setImmediate 会在主线程执行完后立刻执行</span></span>
<span class="line"><span style="color:#6B737C;">// setImmediate 在 IE10 和 node 中支持</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 当在同一轮事件循环中多次调用 nextTick 时 ,timerFunc 只会执行一次</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> timerFunc;</span></span>
<span class="line"><span style="color:#6B737C;">// 判断当前环境是否原生支持 promise</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">!==</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;undefined&quot;</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#B392F0;"> isNative(</span><span style="color:#79B8FF;">Promise</span><span style="color:#B392F0;">)) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 支持 promise</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">p</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#B392F0;">.resolve();</span></span>
<span class="line"><span style="color:#B392F0;">  timerFunc </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 用 promise.then 把 flushCallbacks 函数包裹成一个异步微任务</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">p</span><span style="color:#B392F0;">.then(flushCallbacks);</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (isIOS) setTimeout(noop);</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 标记当前 nextTick 使用的微任务</span></span>
<span class="line"><span style="color:#B392F0;">  isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 如果不支持 promise，就判断是否支持 MutationObserver</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务</span></span>
<span class="line"><span style="color:#B392F0;">} </span><span style="color:#F97583;">else</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">isIE </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">typeof</span><span style="color:#B392F0;"> MutationObserver </span><span style="color:#F97583;">!==</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;undefined&quot;</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#B392F0;">  (isNative(MutationObserver) </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">MutationObserver</span><span style="color:#B392F0;">.toString() </span><span style="color:#F97583;">===</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;[object MutationObserverConstructor]&quot;</span><span style="color:#B392F0;">)</span></span>
<span class="line"><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> counter </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">1</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// new 一个 MutationObserver 类</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">observer</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> MutationObserver(flushCallbacks);</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 创建一个文本节点</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">textNode</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">document</span><span style="color:#B392F0;">.createTextNode(String(counter));</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 监听这个文本节点，当数据发生变化就执行 flushCallbacks</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">observer</span><span style="color:#B392F0;">.observe(textNode</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> { characterData</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;"> });</span></span>
<span class="line"><span style="color:#B392F0;">  timerFunc </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    counter </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> (counter </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">1</span><span style="color:#B392F0;">) </span><span style="color:#F97583;">%</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">2</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">textNode</span><span style="color:#B392F0;">.data </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> String(counter); </span><span style="color:#6B737C;">// 数据更新</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">  isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;">; </span><span style="color:#6B737C;">// 标记当前 nextTick 使用的微任务</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 判断当前环境是否原生支持 setImmediate</span></span>
<span class="line"><span style="color:#B392F0;">} </span><span style="color:#F97583;">else</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#B392F0;"> setImmediate </span><span style="color:#F97583;">!==</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;undefined&quot;</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#B392F0;"> isNative(setImmediate)) {</span></span>
<span class="line"><span style="color:#B392F0;">  timerFunc </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    setImmediate(flushCallbacks);</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">} </span><span style="color:#F97583;">else</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 以上三种都不支持就选择 setTimeout</span></span>
<span class="line"><span style="color:#B392F0;">  timerFunc </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    setTimeout(flushCallbacks</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">0</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 如果多次调用 nextTick，会依次执行上面的方法，将 nextTick 的回调放在 callbacks 数组中</span></span>
<span class="line"><span style="color:#6B737C;">// 最后通过 flushCallbacks 函数遍历 callbacks 数组的拷贝并执行其中的回调</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> flushCallbacks() {</span></span>
<span class="line"><span style="color:#B392F0;">  pending </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">false</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">copies</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">callbacks</span><span style="color:#B392F0;">.slice(</span><span style="color:#F8F8F8;">0</span><span style="color:#B392F0;">); </span><span style="color:#6B737C;">// 拷贝一份 callbacks</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">callbacks</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">length</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">0</span><span style="color:#B392F0;">; </span><span style="color:#6B737C;">// 清空 callbacks</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">for</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> i </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">0</span><span style="color:#B392F0;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">copies</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">length</span><span style="color:#B392F0;">; i</span><span style="color:#F97583;">++</span><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 遍历执行传入的回调</span></span>
<span class="line"><span style="color:#B392F0;">    copies[i]();</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 为什么要拷贝一份 callbacks</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">// 用 callbacks.slice(0) 将 callbacks 拷贝出来一份，</span></span>
<span class="line"><span style="color:#6B737C;">// 是因为考虑到在 nextTick 回调中可能还会调用 nextTick 的情况,</span></span>
<span class="line"><span style="color:#6B737C;">// 如果在 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，</span></span>
<span class="line"><span style="color:#6B737C;">// 而 nextTick 回调中的 nextTick 应该放在下一轮执行，</span></span>
<span class="line"><span style="color:#6B737C;">// 否则就可能出现一直循环的情况，</span></span>
<span class="line"><span style="color:#6B737C;">// 所以需要将 callbacks 复制一份出来然后清空，再遍历备份列表执行回调</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br></div></div>`,12)]))}const b=n(o,[["render",e]]);export{F as __pageData,b as default};
