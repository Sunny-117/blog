import{_ as n,o as a,c as p,a as e}from"./app.f9cf8683.js";const l="/blog/assets/2024-04-15-19-41-41.cddf3090.png",m=JSON.parse('{"title":"输入 npm run xxx 后发生了什么？","description":"","frontmatter":{},"headers":[{"level":2,"title":"问题分析","slug":"问题分析","link":"#问题分析","children":[]},{"level":2,"title":"浅析 npm install 机制阅读","slug":"浅析-npm-install-机制阅读","link":"#浅析-npm-install-机制阅读","children":[]}],"relativePath":"fragment/npm-scripts.md","lastUpdated":1740908463000}'),o={name:"fragment/npm-scripts.md"};function t(r,s,c,i,d,u){return a(),p("div",null,s[0]||(s[0]=[e(`<h1 id="输入-npm-run-xxx-后发生了什么" tabindex="-1">输入 npm run xxx 后发生了什么？ <a class="header-anchor" href="#输入-npm-run-xxx-后发生了什么" aria-hidden="true">#</a></h1><p>在前端开发中，我们经常使用 npm run dev 来启动本地开发环境。那么，当输入完类似 npm run xxx 的命令后，到底发生了什么呢？项目又是如何被启动的？</p><p>首先我们知道，node 可以把 .js 文件当做脚本来运行，例如启动后台项目时经常会输入：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">node </span><span style="color:#98C379;">app.js</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">node </span><span style="color:#9DB1C5;">app.js</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个是直接使用全局安装的 node 命令来执行了 ./src 目录下的 app.js 文件。</p><p>而当我们使用 npm （或者 yarn）来管理项目时，会在根目录下生成一个 package.json 文件，其中的 scripts 属性，就是用于配置 npm run xxx 命令的，比如以下配置：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#98C379;">&quot;scripts&quot;</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">&quot;dev&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;vite&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">&quot;build&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;vite build&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">&quot;preview&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;vite preview&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;">},</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#FFAB70;">&quot;scripts&quot;</span><span style="color:#B392F0;">: {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F8F8F8;">&quot;dev&quot;</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;vite&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F8F8F8;">&quot;build&quot;</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;vite build&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F8F8F8;">&quot;preview&quot;</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;vite preview&quot;</span></span>
<span class="line"><span style="color:#B392F0;">},</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>再看对应的 node_modules 目录下的.bin 目录，里面有一个 vite 文件</p><p>打开 vite 文件可以看到 #!/bin/sh，表示这是一个脚本（node 可以执行）。</p><p><img src="`+l+`" alt=""></p><p>当执行 npm run dev 时，首先会去 package.json 文件中找到 script 属性的&quot;dev&quot;,然后再到 node_modules 目录下的.bin 目录中找到&quot;dev&quot;对应的&quot;vite&quot;，执行 vite（由前面可知 vite 是一个脚本，类似于前面提过的 node app.js）。 再如：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">&quot;dev&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;./node_modules/.bin/nodemon bin/www&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">{</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F8F8F8;">&quot;dev&quot;</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;./node_modules/.bin/nodemon bin/www&quot;</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当执行 npm run dev 时，相当于执行 &quot;./node_modules/.bin/nodemon bin/www&quot;，其中 bin/www 作为参数传入。</p><p>总之：先去 package.json 的 scripts 属性中查找 xxx1,再去./node_modules/.bin 中查找 xxx1 对应的 sss1,执行 sss1 文件）</p><h2 id="问题分析" tabindex="-1">问题分析 <a class="header-anchor" href="#问题分析" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>问题 1： 为什么不直接执行 sss 而要执行 xxx 呢？</p></div><p>直接执行 sss 会报错，因为操作系统中不存在 sss 这一条指令。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>问题 2： 为什么执行 npm run xxx（或者 yarn xxx）时就能成功呢？</p></div><p>因为我们在安装依赖的时候，是通过 npm i xxx (或者 yarn ...)来执行的，例如 npm i @vue/cli-service，npm 在 安装这个依赖的时候，就会 node_modules/.bin/ 目录中创建好名为 vue-cli-service 的几个可执行文件了。</p><p>.bin 目录下的文件，是一个个的软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本，可由 node 来执行。当使用 npm run xxx 执行 sss 时，虽然没有安装 sss 的全局命令，但是 npm 会到 ./node_modules/.bin 中找到 sss 文件作为脚本来执行，则相当于执行了 ./node_modules/.bin/sss。</p><p>即： <strong>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；没有找到则从全局的 node_modules/.bin 中查找； 全局目录还是没找到，就会从 window 的 path 环境变量中查找有没有其他同名的可执行程序。</strong></p><h2 id="浅析-npm-install-机制阅读" tabindex="-1"><a href="https://juejin.cn/post/7206998548343504956" target="_blank" rel="noreferrer">浅析 npm install 机制阅读</a> <a class="header-anchor" href="#浅析-npm-install-机制阅读" aria-hidden="true">#</a></h2>`,22)]))}const y=n(o,[["render",t]]);export{m as __pageData,y as default};
