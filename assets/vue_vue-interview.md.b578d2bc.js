import{_ as o,o as t,c as r,a,b as n,d as l,t as e}from"./app.f9cf8683.js";const u=JSON.parse('{"title":"那些年，被问烂了的 Vuejs 面试题","description":"","frontmatter":{},"headers":[{"level":2,"title":"说一下 v-if 与 v-show 的区别","slug":"说一下-v-if-与-v-show-的区别","link":"#说一下-v-if-与-v-show-的区别","children":[]},{"level":2,"title":"如何让 CSS 值在当前的组件中起作用","slug":"如何让-css-值在当前的组件中起作用","link":"#如何让-css-值在当前的组件中起作用","children":[]},{"level":2,"title":"MVVM的优缺点?","slug":"mvvm的优缺点","link":"#mvvm的优缺点","children":[]},{"level":2,"title":"MVVM、MVC、MVP 的区别","slug":"mvvm、mvc、mvp-的区别","link":"#mvvm、mvc、mvp-的区别","children":[]},{"level":2,"title":"谈一谈对 MVVM 的理解？","slug":"谈一谈对-mvvm-的理解","link":"#谈一谈对-mvvm-的理解","children":[]},{"level":2,"title":"Vue 中如何进行组件的使用？Vue 如何实现全局组件的注册？","slug":"vue-中如何进行组件的使用-vue-如何实现全局组件的注册","link":"#vue-中如何进行组件的使用-vue-如何实现全局组件的注册","children":[]},{"level":2,"title":"Vue 组件的 data 为什么必须是函数","slug":"vue-组件的-data-为什么必须是函数","link":"#vue-组件的-data-为什么必须是函数","children":[]},{"level":2,"title":"vue 如何快速定位那个组件出现性能问题的","slug":"vue-如何快速定位那个组件出现性能问题的","link":"#vue-如何快速定位那个组件出现性能问题的","children":[]},{"level":2,"title":"scoped 是如何实现样式穿透的？","slug":"scoped-是如何实现样式穿透的","link":"#scoped-是如何实现样式穿透的","children":[]},{"level":2,"title":"说一下 ref 的作用是什么？","slug":"说一下-ref-的作用是什么","link":"#说一下-ref-的作用是什么","children":[]},{"level":2,"title":"说一下你知道的 vue 修饰符都有哪些？","slug":"说一下你知道的-vue-修饰符都有哪些","link":"#说一下你知道的-vue-修饰符都有哪些","children":[]},{"level":2,"title":"Vue.extend 和 Vue.component 的区别是什么？","slug":"vue-extend-和-vue-component-的区别是什么","link":"#vue-extend-和-vue-component-的区别是什么","children":[]},{"level":2,"title":"移动端如何实现一个比较友好的 header 组件","slug":"移动端如何实现一个比较友好的-header-组件","link":"#移动端如何实现一个比较友好的-header-组件","children":[]},{"level":2,"title":"既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？","slug":"既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-监测差异","link":"#既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-监测差异","children":[]},{"level":2,"title":"Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？","slug":"vue-为什么没有类似于-react-中-shouldcomponentupdate-的生命周期","link":"#vue-为什么没有类似于-react-中-shouldcomponentupdate-的生命周期","children":[]},{"level":2,"title":"说一下你对 vue 事件绑定原理的理解？","slug":"说一下你对-vue-事件绑定原理的理解","link":"#说一下你对-vue-事件绑定原理的理解","children":[]},{"level":2,"title":"delete 和 Vue.delete 删除数组的区别是什么？","slug":"delete-和-vue-delete-删除数组的区别是什么","link":"#delete-和-vue-delete-删除数组的区别是什么","children":[]},{"level":2,"title":"v-on 可以实现监听多个方法么？","slug":"v-on-可以实现监听多个方法么","link":"#v-on-可以实现监听多个方法么","children":[]},{"level":2,"title":"vue 的数据为什么频繁变化但只会更新一次？","slug":"vue-的数据为什么频繁变化但只会更新一次","link":"#vue-的数据为什么频繁变化但只会更新一次","children":[]},{"level":2,"title":"插槽与作用域插槽的区别是什么？","slug":"插槽与作用域插槽的区别是什么","link":"#插槽与作用域插槽的区别是什么","children":[]},{"level":2,"title":"vue 中相同逻辑如何进行抽离？","slug":"vue-中相同逻辑如何进行抽离","link":"#vue-中相同逻辑如何进行抽离","children":[]},{"level":2,"title":"说一说自定义指令有哪些生命周期？","slug":"说一说自定义指令有哪些生命周期","link":"#说一说自定义指令有哪些生命周期","children":[]},{"level":2,"title":"vue 为什么采用异步渲染","slug":"vue-为什么采用异步渲染","link":"#vue-为什么采用异步渲染","children":[]},{"level":2,"title":"组件中写 name 选项有哪些好处","slug":"组件中写-name-选项有哪些好处","link":"#组件中写-name-选项有哪些好处","children":[]},{"level":2,"title":"过滤器的作用，如何实现一个过滤器","slug":"过滤器的作用-如何实现一个过滤器","link":"#过滤器的作用-如何实现一个过滤器","children":[]},{"level":2,"title":"如何保存页面的当前的状态","slug":"如何保存页面的当前的状态","link":"#如何保存页面的当前的状态","children":[]},{"level":2,"title":"常见的事件修饰符及其作用","slug":"常见的事件修饰符及其作用","link":"#常见的事件修饰符及其作用","children":[]},{"level":2,"title":"v-if、v-show、v-html 的原理","slug":"v-if、v-show、v-html-的原理","link":"#v-if、v-show、v-html-的原理","children":[]},{"level":2,"title":"data 为什么是一个函数而不是对象","slug":"data-为什么是一个函数而不是对象","link":"#data-为什么是一个函数而不是对象","children":[]},{"level":2,"title":"Vue 中封装的数组方法有哪些，其如何实现页面更新","slug":"vue-中封装的数组方法有哪些-其如何实现页面更新","link":"#vue-中封装的数组方法有哪些-其如何实现页面更新","children":[]},{"level":2,"title":"Vue 单页应用与多页应用的区别","slug":"vue-单页应用与多页应用的区别","link":"#vue-单页应用与多页应用的区别","children":[]},{"level":2,"title":"Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？","slug":"vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗","link":"#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗","children":[]},{"level":2,"title":"简述 mixin、extends 的覆盖逻辑","slug":"简述-mixin、extends-的覆盖逻辑","link":"#简述-mixin、extends-的覆盖逻辑","children":[]},{"level":2,"title":"assets 和 static 的区别","slug":"assets-和-static-的区别","link":"#assets-和-static-的区别","children":[]},{"level":2,"title":"delete 和 Vue.delete 删除数组的区别","slug":"delete-和-vue-delete-删除数组的区别","link":"#delete-和-vue-delete-删除数组的区别","children":[]},{"level":2,"title":"什么是 mixin ？","slug":"什么是-mixin","link":"#什么是-mixin","children":[]},{"level":2,"title":"template 和 jsx 的有什么分别？","slug":"template-和-jsx-的有什么分别","link":"#template-和-jsx-的有什么分别","children":[]},{"level":2,"title":"vue 初始化页面闪动问题","slug":"vue-初始化页面闪动问题","link":"#vue-初始化页面闪动问题","children":[]},{"level":2,"title":"extend 有什么作用","slug":"extend-有什么作用","link":"#extend-有什么作用","children":[]},{"level":2,"title":"mixin 和 mixins 区别","slug":"mixin-和-mixins-区别","link":"#mixin-和-mixins-区别","children":[]},{"level":2,"title":"内置组件 Transition","slug":"内置组件-transition","link":"#内置组件-transition","children":[]},{"level":2,"title":"过渡组","slug":"过渡组","link":"#过渡组","children":[]}],"relativePath":"vue/vue-interview.md","lastUpdated":1740908463000}'),c={name:"vue/vue-interview.md"};function i(p,s,B,y,F,m){return t(),r("div",null,[s[3]||(s[3]=a(`<h1 id="那些年-被问烂了的-vuejs-面试题" tabindex="-1">那些年，被问烂了的 Vuejs 面试题 <a class="header-anchor" href="#那些年-被问烂了的-vuejs-面试题" aria-hidden="true">#</a></h1><h2 id="说一下-v-if-与-v-show-的区别" tabindex="-1"><strong>说一下 <em>v-if</em> 与 <em>v-show</em> 的区别</strong> <a class="header-anchor" href="#说一下-v-if-与-v-show-的区别" aria-hidden="true">#</a></h2><blockquote><ul><li>共同点：都是动态显示 <em>DOM</em> 元素</li><li>区别点: <ul><li>手段 <em>v-if</em> 是动态的向 <em>DOM</em> 树内添加或者删除 <em>DOM</em> 元素 <em>v-show</em> 是通过设置 <em>DOM</em> 元素的 <em>display</em> 样式属性控制显隐</li><li>编译过程 <em>v-if</em>   切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 <em>v-show</em> 只是简单的基于 <em>css</em> 切换</li><li>编译条件 <em>v-if</em>   是惰性的，如果初始条件为假，则什么也不做。只有在条件第一次变为真时才开始局部编译 <em>v-show</em> 是在任何条件下(首次条件是否为真)都被编译，然后被缓存，而且 <em>DOM</em> 元素保留</li><li>性能消耗 <em>v-if</em>   有更高的切换消耗 <em>v-show</em> 有更高的初始渲染消耗</li><li>使用场景 <em>v-if</em>   适合运营条件不大可能改变 <em>v-show</em> 适合频繁切换</li></ul></li></ul></blockquote><h2 id="如何让-css-值在当前的组件中起作用" tabindex="-1"><strong>如何让 <em>CSS</em> 值在当前的组件中起作用</strong> <a class="header-anchor" href="#如何让-css-值在当前的组件中起作用" aria-hidden="true">#</a></h2><blockquote><p>在 <em>vue</em> 文件中的 <em>style</em> 标签上，有一个特殊的属性：<em>scoped</em>。当一个 style 标签拥有 <em>scoped</em> 属性时，它的 <em>CSS</em> 样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 <em>style</em> 标签全部加上了 <em>scoped</em>，相当于实现了样式的模块化。</p><p><strong><em>scoped</em> 的实现原理</strong></p><p><em>vue</em> 中的 <em>scoped</em> 属性的效果主要通过 <em>PostCSS</em> 转译实现的。<em>PostCSS</em> 给一个组件中的所有 <em>DOM</em> 添加了一个独一无二的动态属性，然后，给 <em>CSS</em> 选择器额外添加一个对应的属性选择器来选择该组件中 <em>DOM</em>，这种做法使得样式只作用于含有该属性的 <em>DOM</em>，即组件内部 <em>DOM</em>。</p><p>例如：</p><p>转译前</p></blockquote><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">  &lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">class</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">&quot;example&quot;</span><span style="color:#ABB2BF;">&gt;hi&lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">scoped</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">.example </span><span style="color:#C678DD;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">color</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">  &lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;"> class</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;example&quot;</span><span style="color:#B392F0;">&gt;hi&lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;"> scoped&gt;</span></span>
<span class="line"><span style="color:#B392F0;">.example {</span></span>
<span class="line"><span style="color:#B392F0;">  color: red;</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>转译后：</p></blockquote><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">  &lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">class</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">&quot;example&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">data-v-5558831a</span><span style="color:#ABB2BF;">&gt;hi&lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">.example[data-v-5558831a] </span><span style="color:#C678DD;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">color</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">  &lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;"> class</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;example&quot;</span><span style="color:#B392F0;"> data-v-5558831a&gt;hi&lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">.example[data-v-5558831a] {</span></span>
<span class="line"><span style="color:#B392F0;">  color: red;</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="mvvm的优缺点" tabindex="-1"><strong>MVVM</strong>的优缺点? <a class="header-anchor" href="#mvvm的优缺点" aria-hidden="true">#</a></h2><p>优点:</p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定不同的&quot;View&quot;上，当 View 变化的时候 Model 不可以不变，当 Model 变化的时候 View 也可以不变。你可以把⼀些视图逻辑放在⼀个 ViewModel ⾥⾯，让很多 view 重⽤这段视图逻辑</li><li>提⾼可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代码</li><li>⾃动更新 dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动 dom 中解放</li></ul><p>缺点:</p><ul><li>Bug 很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的</li><li>⼀个⼤的模块中 model 也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼。</li></ul><h2 id="mvvm、mvc、mvp-的区别" tabindex="-1">MVVM、MVC、MVP 的区别 <a class="header-anchor" href="#mvvm、mvc、mvp-的区别" aria-hidden="true">#</a></h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。</p><p>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。</p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h2 id="谈一谈对-mvvm-的理解" tabindex="-1"><strong>谈一谈对 MVVM 的理解？</strong> <a class="header-anchor" href="#谈一谈对-mvvm-的理解" aria-hidden="true">#</a></h2><blockquote><ul><li><em>MVVM</em> 是 <em>Model-View-ViewModel</em> 的缩写。<em>MVVM</em> 是一种设计思想。</li><li><em>Model</em> 层代表数据模型，也可以在 <em>Model</em> 中定义数据修改和操作的业务逻辑;</li><li><em>View</em> 代表 <em>UI</em> 组件，它负责将数据模型转化成 <em>UI</em> 展现出来，<em>View</em> 是一个同步 <em>View</em> 和 <em>Model</em> 的对象</li><li>在 <em>MVVM</em> 架构下，<em>View</em> 和 <em>Model</em> 之间并没有直接的联系，而是通过 <em>ViewModel</em> 进行交互， <em>Model</em> 和 <em>ViewModel</em> 之间的交互是双向的， 因此 <em>View</em> 数据的变化会同步到 <em>Model</em> 中，而 <em>Model</em> 数据的变化也会立即反应到 <em>View</em> 上。</li><li>对 <em>ViewModel</em> 通过双向数据绑定把 <em>View</em> 层和 <em>Model</em> 层连接了起来，而 <em>View</em> 和 <em>Model</em> 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 <em>DOM</em>，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 <em>MVVM</em> 来统一管理。</li></ul></blockquote><h2 id="vue-中如何进行组件的使用-vue-如何实现全局组件的注册" tabindex="-1"><strong><em>Vue</em> 中如何进行组件的使用？<em>Vue</em> 如何实现全局组件的注册？</strong> <a class="header-anchor" href="#vue-中如何进行组件的使用-vue-如何实现全局组件的注册" aria-hidden="true">#</a></h2><blockquote><p>要使用组件，首先需要使用 <em>import</em> 来引入组件，然后在 <em>components</em> 属性中注册组件，之后就可以在模板中使用组件了。</p><p>可以使用 <em>Vue.component</em> 方法来实现全局组件的注册。</p></blockquote><h2 id="vue-组件的-data-为什么必须是函数" tabindex="-1"><strong><em>Vue</em> 组件的 <em>data</em> 为什么必须是函数</strong> <a class="header-anchor" href="#vue-组件的-data-为什么必须是函数" aria-hidden="true">#</a></h2><blockquote><p>组件中的 <em>data</em> 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 <em>data</em>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 <em>data</em>，就会造成一个变了全都会变的结果。</p></blockquote><h2 id="vue-如何快速定位那个组件出现性能问题的" tabindex="-1"><strong><em>vue</em> 如何快速定位那个组件出现性能问题的</strong> <a class="header-anchor" href="#vue-如何快速定位那个组件出现性能问题的" aria-hidden="true">#</a></h2><blockquote><p>⽤ <em>timeline</em> ⼯具。 通过 <em>timeline</em> 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。</p></blockquote><h2 id="scoped-是如何实现样式穿透的" tabindex="-1"><strong><em>scoped</em> 是如何实现样式穿透的？</strong> <a class="header-anchor" href="#scoped-是如何实现样式穿透的" aria-hidden="true">#</a></h2><blockquote><p>首先说一下什么场景下需要 <em>scoped</em> 样式穿透。</p><p>在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 <em>scoped</em> 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 <em>scoped</em>。</p><p>有三种常用的方法来实现样式穿透。</p><p><strong>方法一</strong></p><p>使用 <em>::v-deep</em> 操作符( &gt;&gt;&gt; 的别名)</p><p>如果希望 <em>scoped</em> 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 &gt;&gt;&gt; 操作符：</p><p>上述代码将会编译成：</p><p>后面的类名没有 <em>data</em> 属性，所以能选到子组件里面的类名。</p><p>有些像 <em>Sass</em> 之类的预处理器无法正确解析 &gt;&gt;&gt;，所以需要使用 <em>::v-deep</em> 操作符来代替。</p><p><strong>方法二</strong></p><p>定义一个含有 <em>scoped</em> 属性的 <em>style</em> 标签之外，再定义一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，即在一个 <em>vue</em> 组件中定义一个全局的 <em>style</em> 标签，一个含有作用域的 <em>style</em> 标签：</p><p>此时，我们只需要将修改第三方样式的 <em>css</em> 写在第一个 <em>style</em> 中即可。</p><p><strong>方法三</strong></p><p>上面的方法一需要单独书写一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，可能会造成全局样式的污染。</p><p>更推荐的方式是在组件的外层 <em>DOM</em> 上添加唯一的 <em>class</em> 来区分不同组件，在书写样式时就可以正常针对针对这部分 <em>DOM</em> 书写样式。</p></blockquote><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">scoped</span><span style="color:#ABB2BF;">&gt;.a &gt;&gt;&gt; .b </span><span style="color:#C678DD;">{</span><span style="color:#7F848E;font-style:italic;">/* ... */</span><span style="color:#C678DD;">}</span><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;"> scoped&gt;.a &gt;&gt;&gt; .b {</span><span style="color:#6B737C;">/* ... */</span><span style="color:#B392F0;">}&lt;/</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">data</span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;">v</span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;">f3f3eg9</span><span style="color:#ABB2BF;">] .</span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;"> { </span><span style="color:#7F848E;font-style:italic;">/* ... */</span><span style="color:#ABB2BF;"> }</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">.a[data</span><span style="color:#F97583;">-</span><span style="color:#B392F0;">v</span><span style="color:#F97583;">-</span><span style="color:#B392F0;">f3f3eg9] .b { </span><span style="color:#6B737C;">/* ... */</span><span style="color:#B392F0;"> }</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">/* global styles */</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;font-style:italic;">scoped</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">/* local styles */</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">style</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">/* global styles */</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;"> scoped&gt;</span></span>
<span class="line"><span style="color:#B392F0;">/* local styles */</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">style</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="说一下-ref-的作用是什么" tabindex="-1"><strong>说一下 <em>ref</em> 的作用是什么？</strong> <a class="header-anchor" href="#说一下-ref-的作用是什么" aria-hidden="true">#</a></h2><blockquote><p><em>ref</em> 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <em>$refs</em> 对象上。其特点是：</p><ul><li>如果在普通的 <em>DOM</em> 元素上使用，引用指向的就是 <em>DOM</em> 元素</li><li>如果用在子组件上，引用就指向组件实例</li></ul></blockquote><blockquote><p>所以常见的使用场景有：</p><ol><li>基本用法，本页面获取 <em>DOM</em> 元素</li><li>获取子组件中的 <em>data</em></li><li>调用子组件中的方法</li></ol></blockquote><h2 id="说一下你知道的-vue-修饰符都有哪些" tabindex="-1"><strong>说一下你知道的 <em>vue</em> 修饰符都有哪些？</strong> <a class="header-anchor" href="#说一下你知道的-vue-修饰符都有哪些" aria-hidden="true">#</a></h2><blockquote><p>在 <em>vue</em> 中修饰符可以分为 <em>3</em> 类：</p><ul><li>事件修饰符</li><li>按键修饰符</li><li>表单修饰符</li></ul></blockquote><blockquote><p><strong>事件修饰符</strong></p><p>在事件处理程序中调用 <em>event.preventDefault</em> 或 <em>event.stopPropagation</em> 方法是非常常见的需求。尽管可以在 <em>methods</em> 中轻松实现这点，但更好的方式是：<em>methods</em> 只有纯粹的数据逻辑，而不是去处理 <em>DOM</em> 事件细节。</p><p>为了解决这个问题，<em>vue</em> 为 <em>v-on</em> 提供了事件修饰符。通过由点 <em>.</em> 表示的指令后缀来调用修饰符。</p><p>常见的事件修饰符如下：</p><ul><li><em>.stop</em>：阻止冒泡。</li><li><em>.prevent</em>：阻止默认事件。</li><li><em>.capture</em>：使用事件捕获模式。</li><li><em>.self</em>：只在当前元素本身触发。</li><li><em>.once</em>：只触发一次。</li><li><em>.passive</em>：默认行为将会立即触发。</li></ul></blockquote><blockquote><p><strong>按键修饰符</strong></p><p>除了事件修饰符以外，在 <em>vue</em> 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。</p><ul><li>.<em>left</em>：左键</li><li>.<em>right</em>：右键</li><li>.<em>middle</em>：滚轮</li><li>.<em>enter</em>：回车</li><li>.<em>tab</em>：制表键</li><li>.<em>delete</em>：捕获 “删除” 和 “退格” 键</li><li>.<em>esc</em>：返回</li><li>.<em>space</em>：空格</li><li>.<em>up</em>：上</li><li>.<em>down</em>：下</li><li>.<em>left</em>：左</li><li>.<em>right</em>：右</li><li>.<em>ctrl</em>：<em>ctrl</em> 键</li><li>.<em>alt</em>：<em>alt</em> 键</li><li>.<em>shift</em>：<em>shift</em> 键</li><li>.<em>meta</em>：<em>meta</em> 键</li></ul></blockquote><blockquote><p><strong>表单修饰符</strong></p><p><em>vue</em> 同样也为表单控件也提供了修饰符，常见的有 <em>.lazy</em>、<em>.number</em> 和 <em>.trim</em>。</p><ul><li>.<em>lazy</em>：在文本框失去焦点时才会渲染</li><li>.<em>number</em>：将文本框中所输入的内容转换为 number 类型</li><li>.<em>trim</em>：可以自动过滤输入首尾的空格</li></ul></blockquote><h2 id="vue-extend-和-vue-component-的区别是什么" tabindex="-1"><strong><em>Vue.extend</em> 和 <em>Vue.component</em> 的区别是什么？</strong> <a class="header-anchor" href="#vue-extend-和-vue-component-的区别是什么" aria-hidden="true">#</a></h2><blockquote><p><em>Vue.extend</em> 用于创建一个基于 <em>Vue</em> 构造函数的“子类”，其参数应为一个包含组件选项的对象。</p><p><em>Vue.component</em> 用来注册全局组件。</p></blockquote><h2 id="移动端如何实现一个比较友好的-header-组件" tabindex="-1"><strong>移动端如何实现一个比较友好的 <em>header</em> 组件</strong> <a class="header-anchor" href="#移动端如何实现一个比较友好的-header-组件" aria-hidden="true">#</a></h2><blockquote><p><em>Header</em> 一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过 <em>vue props</em>的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过 <em>vue slot</em> 插槽的方式对外暴露以实现多样化，同时也可以提供 <em>default slot</em> 默认插槽来统一页面风格。</p></blockquote><h2 id="既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-监测差异" tabindex="-1"><strong>既然 <em>Vue</em> 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 <em>DOM</em> 进行 <em>diff</em> 监测差异 ？</strong> <a class="header-anchor" href="#既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-监测差异" aria-hidden="true">#</a></h2><blockquote><p>现代前端框架有两种方式侦测变化，一种是 <em>pull</em>，一种是 <em>push</em>。</p><p><strong><em>pull</em></strong></p><p>其代表为 <em>React</em>，我们可以回忆一下 <em>React</em> 是如何侦测到变化的。</p><p>我们通常会用 <em>setState API</em> 显式更新,然后 <em>React</em> 会进行一层层的 <em>Virtual Dom Diff</em> 操作找出差异，然后 <em>Patch</em> 到 <em>DOM</em> 上，<em>React</em> 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的 <em>Diff</em> 操作查找「哪发生变化了」，另外一个代表就是 <em>Angular</em> 的脏检查操作。</p><p><strong><em>push</em></strong></p><p><em>Vue</em> 的响应式系统则是 <em>push</em> 的代表，当 <em>Vue</em> 程序初始化的时候就会对数据 <em>data</em> 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 <em>Vue</em> 是一开始就知道是「在哪发生变化了」</p><p>但是这又会产生一个问题，通常绑定一个数据就需要一个 <em>Watcher</em>，一但我们的绑定细粒度过高就会产生大量的 <em>Watcher</em>，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 <em>Vue</em> 的设计是选择中等细粒度的方案，在组件级别进行 <em>push</em> 侦测的方式，也就是那套响应式系统。</p><p>通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 <em>Virtual Dom Diff</em> 获取更加具体的差异，而 <em>Virtual Dom Diff</em> 则是 <em>pull</em> 操作，<em>Vue</em> 是 <em>push + pull</em> 结合的方式进行变化侦测的。</p></blockquote><h2 id="vue-为什么没有类似于-react-中-shouldcomponentupdate-的生命周期" tabindex="-1"><strong><em>Vue</em> 为什么没有类似于 <em>React</em> 中 <em>shouldComponentUpdate</em> 的生命周期？</strong> <a class="header-anchor" href="#vue-为什么没有类似于-react-中-shouldcomponentupdate-的生命周期" aria-hidden="true">#</a></h2><blockquote><p>根本原因是 <em>Vue</em> 与 <em>React</em> 的变化侦测方式有所不同</p><p><em>React</em> 是 <em>pull</em> 的方式侦测变化，当 <em>React</em> 知道发生变化后，会使用 <em>Virtual Dom Diff</em> 进行差异检测,但是很多组件实际上是肯定不会发生变化的，这个时候需要用 <em>shouldComponentUpdate</em> 进行手动操作来减少 <em>diff</em>，从而提高程序整体的性能。</p><p><em>Vue</em> 是 <em>pull+push</em> 的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在 <em>push</em> 的阶段并不需要手动控制 <em>diff</em>，而组件内部采用的 <em>diff</em> 方式实际上是可以引入类似于 <em>shouldComponentUpdate</em> 相关生命周期的，但是通常合理大小的组件不会有过量的 <em>diff</em>，手动优化的价值有限，因此目前 <em>Vue</em> 并没有考虑引入 <em>shouldComponentUpdate</em> 这种手动优化的生命周期。</p></blockquote><h2 id="说一下你对-vue-事件绑定原理的理解" tabindex="-1"><strong>说一下你对 <em>vue</em> 事件绑定原理的理解？</strong> <a class="header-anchor" href="#说一下你对-vue-事件绑定原理的理解" aria-hidden="true">#</a></h2><blockquote><p><em>vue</em> 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。</p><p>原生的事件绑定在普通元素上是通过 @click _ 进行绑定，在组件上是通过 @click.native 进行绑定，组件中的 _nativeOn_ 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的 $on 方法来实现的，必须有 $emit 才可以触发。</p><p><strong>原生事件绑定原理</strong></p><p>在 runtime 下的 patch.js 中 createPatchFunction 执行了之后再赋值给 patch。</p><p>createPatchFunction 方法有两个参数，分别是 nodeOps 存放操作 dom 节点的方法和 modules，modules 是有两个数组拼接起来的，modules 拼接完的数组中有一个元素就是 events，事件添加就发生在这里。</p><p>events 元素关联的就是 events.js 文件，在 events 中有一个 updateDOMListeners 方法，在 events 文件的结尾导出了一个对象，然后对象有一个属性叫做 create，这个属性关联的就是 updateDOMListeners 方法。</p><p>在执行 createPatchFunction 方法时，就会将这两个参数传入，在 createPatchFunction 方法中接收了一个参数 backend，在该方法中一开始进行 backend 的解构，就是上面的 nodeOps 和 modules 参数，解构完之后进入 for 循环。</p><p>在 createPatchFunction 开头定义了一个 cbs 对象。for 循环遍历一个叫 hooks 的数组。hooks 是文件一开头定义的一个数组，其中包括有 create，for 循环就是在 cbs 上定义一系列和 hooks 元素相同的属性，然后键值是一个数组，然后数组内容是 modules 里面的一些内容。这时就把 events 文件中导出来的 create 属性放在了 cbs 上。</p><p>当我们进入首次渲染的时候，会执行到 patch 函数里面的 createElm 方法，这个方法中就会调用 invokeCreateHooks 函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks 方法中，遍历了 cbs.create 数组里面的内容。然后把 cbs.create 里面的函数全部都执行一次，在 cbs.create 其中一个函数就是 updateDOMListeners。</p><p>updateDOMListeners 就是用来添加事件的方法，在这方法中会根据 vnode 判断是否有定义一个点击事件。如果没有点击事件就 return。有的话就继续执行，给 on 进行赋值，然后进行一些赋值操作，将 vnode.elm 赋值给 target，elm 这个属性就是指向 vnode 所对应的真实 dom 节点，这里就是把我们要绑定事件的 dom 结点进行缓存，接下来执行 updateListeners 方法。在接下来执行 updateListeners 方法中调用了一个 add 的方法，然后在 app 方法中通过原生 addEventListener 把事件绑定到 dom 上。</p><p><strong>组件事件绑定原理</strong></p><p>在组件实例初始化会调用 initMixin 方法中的 Vue.prototype._init，在 init 函数中，会通过 initInternalComponent 方法初始化组件信息，将自定义的组件事件放到_parentListeners 上，下来就会调用 initEvents 来初始化组件事件，在 initEvents 中会实例上添加一个 _event 对象，用于保存自定义事件，然后获取到 父组件给 子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners 上，这时候 vm.$options._parentListeners 就是自定义的事件。</p><p>最后进行判断，如果有自定义的组件事件就执行 updateComponentListeners 方法进行事件绑定，在 updateComponentListeners 方法中会调用 updateListeners 方法，并传传一个 add 方法进行执行，这个 add 方法里就是$on 方法。</p></blockquote><h2 id="delete-和-vue-delete-删除数组的区别是什么" tabindex="-1"><strong><em>delete</em> 和 <em>Vue.delete</em> 删除数组的区别是什么？</strong> <a class="header-anchor" href="#delete-和-vue-delete-删除数组的区别是什么" aria-hidden="true">#</a></h2><blockquote><p><em>delete</em> 只是被删除的元素变成了 <em>empty/undefined</em> 其他的元素的键值还是不变。 <em>Vue.delete</em> 是直接将元素从数组中完全删除，改变了数组其他元素的键值。</p></blockquote><h2 id="v-on-可以实现监听多个方法么" tabindex="-1"><strong><em>v-on</em> 可以实现监听多个方法么？</strong> <a class="header-anchor" href="#v-on-可以实现监听多个方法么" aria-hidden="true">#</a></h2><blockquote><p>可以监听多个方法。关于监听多个方法提供了几种不同的写法：</p><p>示例代码如下：</p></blockquote><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">写法一：</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">v-on</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;{ 事件类型: 事件处理函数, 事件类型: 事件处理函数 }&quot;</span><span style="color:#ABB2BF;">&gt;&lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">写法二：</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@事件类型</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;“事件处理函数”&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@事件类型</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;“事件处理函数”&quot;</span><span style="color:#ABB2BF;">&gt;&lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">写法三：在一个事件里面书写多个事件处理函数</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@事件类型</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;“事件处理函数1，事件处理函数2”&quot;</span><span style="color:#ABB2BF;">&gt;&lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">写法四：在事件处理函数内部调用其他的函数</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">写法一：</span></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;"> v-on</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;{ 事件类型: 事件处理函数, 事件类型: 事件处理函数 }&quot;</span><span style="color:#B392F0;">&gt;&lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">写法二：</span></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;"> @事件类型</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;“事件处理函数”&quot;</span><span style="color:#B392F0;"> @事件类型</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;“事件处理函数”&quot;</span><span style="color:#B392F0;">&gt;&lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">写法三：在一个事件里面书写多个事件处理函数</span></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;"> @事件类型</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;“事件处理函数1，事件处理函数2”&quot;</span><span style="color:#B392F0;">&gt;&lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">写法四：在事件处理函数内部调用其他的函数</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">  &lt;</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">    &lt;</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">v-on</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;{ mouseenter: onEnter, mouseleave: onLeave }&quot;</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">      鼠标进来1</span></span>
<span class="line"><span style="color:#ABB2BF;">    &lt;/</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">    &lt;</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@mouseenter</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;onEnter&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@mouseleave</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;onLeave&quot;</span><span style="color:#ABB2BF;">&gt;鼠标进来2&lt;/</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">    &lt;</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@click</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;a(), b()&quot;</span><span style="color:#ABB2BF;">&gt;点我ab&lt;/</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">    &lt;</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">@click</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;one()&quot;</span><span style="color:#ABB2BF;">&gt;点我onetwothree&lt;/</span><span style="color:#E06C75;">button</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">  &lt;/</span><span style="color:#E06C75;">div</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">script</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">export</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">default</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">methods</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#7F848E;font-style:italic;">//这里是es6对象里函数写法</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">a</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;a&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">b</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;b&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">one</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;one&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">two</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">three</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">two</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;two&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">three</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;three&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">onEnter</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;mouse enter&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#61AFEF;">onLeave</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;mouse leave&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">      },</span></span>
<span class="line"><span style="color:#ABB2BF;">    },</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/</span><span style="color:#E06C75;">script</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">  &lt;</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span>
<span class="line"><span style="color:#B392F0;">    &lt;</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;"> v-on</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;{ mouseenter: onEnter, mouseleave: onLeave }&quot;</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">      鼠标进来1</span></span>
<span class="line"><span style="color:#B392F0;">    &lt;/</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">    &lt;</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;"> @mouseenter</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;onEnter&quot;</span><span style="color:#B392F0;"> @mouseleave</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;onLeave&quot;</span><span style="color:#B392F0;">&gt;鼠标进来2&lt;/</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span>
<span class="line"><span style="color:#B392F0;">    &lt;</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;"> @click</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;a(), b()&quot;</span><span style="color:#B392F0;">&gt;点我ab&lt;/</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">    &lt;</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;"> @click</span><span style="color:#F97583;">=</span><span style="color:#FFAB70;">&quot;one()&quot;</span><span style="color:#B392F0;">&gt;点我onetwothree&lt;/</span><span style="color:#FFAB70;">button</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">  &lt;/</span><span style="color:#FFAB70;">div</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">template</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">script</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">export</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">default</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    methods</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#6B737C;">//这里是es6对象里函数写法</span></span>
<span class="line"><span style="color:#B392F0;">      a() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;a&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      b() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;b&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      one() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;one&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.two();</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.three();</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      two() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;two&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      three() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;three&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      onEnter() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;mouse enter&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">      onLeave() {</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#79B8FF;">console</span><span style="color:#B392F0;">.log(</span><span style="color:#FFAB70;">&quot;mouse leave&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">      }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">    }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/</span><span style="color:#FFAB70;">script</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h2 id="vue-的数据为什么频繁变化但只会更新一次" tabindex="-1"><strong><em>vue</em> 的数据为什么频繁变化但只会更新一次？</strong> <a class="header-anchor" href="#vue-的数据为什么频繁变化但只会更新一次" aria-hidden="true">#</a></h2><blockquote><p>这是因为 <em>vue</em> 的 <em>DOM</em> 更新是一个异步操作，在数据更新后会首先被 <em>set</em> 钩子监听到，但是不会马上执行 <em>DOM</em> 更新，而是在下一轮循环中执行更新。</p><p>具体实现是 <em>vue</em> 中实现了一个 <em>queue</em> 队列用于存放本次事件循环中的所有 <em>watcher</em> 更新，并且同一个 <em>watcher</em> 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(<em>UI Render</em> 阶段)，这就是 <em>DOM</em> 只会更新一次的原因。</p><p>这种在缓冲时去除重复数据对于避免不必要的计算和 <em>DOM</em> 操作是非常重要的。然后，在下一个的事件循环“<em>tick</em>”中，<em>vue</em> 刷新队列并执行实际 (已去重的) 工作。<em>vue</em> 在内部对异步队列尝试使用原生的 <em>Promise.then、MutationObserver</em>   和 <em>setImmediate</em>，如果执行环境不支持，则会采用 <em>setTimeout(fn, 0)</em> 代替。</p></blockquote><h2 id="插槽与作用域插槽的区别是什么" tabindex="-1"><strong>插槽与作用域插槽的区别是什么？</strong> <a class="header-anchor" href="#插槽与作用域插槽的区别是什么" aria-hidden="true">#</a></h2><blockquote><p>插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。</p><p>作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。</p></blockquote><h2 id="vue-中相同逻辑如何进行抽离" tabindex="-1"><strong><em>vue</em> 中相同逻辑如何进行抽离？</strong> <a class="header-anchor" href="#vue-中相同逻辑如何进行抽离" aria-hidden="true">#</a></h2><blockquote><p>可以使用 <em>vue</em> 里面的混入（<em>mixin</em>）技术。混入（<em>mixin</em>）提供了一种非常灵活的方式，来将 <em>vue</em> 中相同的业务逻辑进行抽离。</p><p>例如：</p><ul><li>在 <em>data</em> 中有很多是公用数据</li><li>引用封装好的组件也都是一样的</li><li><em>methods、watch、computed</em> 中也都有大量的重复代码</li></ul></blockquote><blockquote><p>当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 <em>mixin</em> 就可以大展身手了。</p><p>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p><p><strong>混入技术特点</strong></p><ul><li>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li><li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li><li>值为对象的选项，例如 <em>methods、components</em> 和 <em>directives</em>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li></ul></blockquote><h2 id="说一说自定义指令有哪些生命周期" tabindex="-1">说一说自定义指令有哪些生命周期？ <a class="header-anchor" href="#说一说自定义指令有哪些生命周期" aria-hidden="true">#</a></h2><blockquote><p>自定义指令的生命周期，有 5 个事件钩子，可以设置指令在某一个事件发生时的具体行为：</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次， 指令与元素解绑时调用。</li></ul></blockquote><blockquote><p>钩子函数的参数 (包括 el，binding，vnode，oldVnode)</p><ul><li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li><li>binding: 一个对象，包含以下属性：name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。</li><li>vnode: Vue 编译生成的虚拟节点。</li><li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul></blockquote><h2 id="vue-为什么采用异步渲染" tabindex="-1"><em>vue</em> 为什么采用异步渲染 <a class="header-anchor" href="#vue-为什么采用异步渲染" aria-hidden="true">#</a></h2><blockquote><p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；所以为了性能考虑，<em>Vue</em> 会在本轮数据更新后，再去异步更新视图。</p><p>异步渲染的原理：</p><ol><li>调用 <em>notify( )</em> 方法，通知 <em>watcher</em> 进行更新操作</li><li>依次调用 watcher 的 update 方法</li><li>对 watcher 进行去重操作（通过 id）放到队列里</li><li>执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作</li></ol></blockquote><h2 id="组件中写-name-选项有哪些好处" tabindex="-1">组件中写 <em>name</em> 选项有哪些好处 <a class="header-anchor" href="#组件中写-name-选项有哪些好处" aria-hidden="true">#</a></h2><blockquote><ol><li>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</li><li>可以通过 <em>name</em> 属性实现缓存功能（<em>keep-alive</em>）</li><li>可以通过 <em>name</em> 来识别组件（跨级组件通信时非常重要）</li><li>使用 <em>vue-devtools</em> 调试工具里显示的组见名称是由 <em>vue</em> 中组件 <em>name</em> 决定的</li></ol></blockquote><h2 id="过滤器的作用-如何实现一个过滤器" tabindex="-1">过滤器的作用，如何实现一个过滤器 <a class="header-anchor" href="#过滤器的作用-如何实现一个过滤器" aria-hidden="true">#</a></h2><p>根据过滤器的名称，过滤器是用来过滤数据的，在 Vue 中使用 filters 来过滤数据，filters 不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。</p><p><strong>使用场景：</strong></p><ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li><li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用 fliters 过滤器来处理数据。</li></ul>`,80)),n("p",null,[s[0]||(s[0]=l("过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在")),s[1]||(s[1]=n("strong",null,"插值表达式 *",-1)),n("em",null,[n("strong",null,e()+" 和 v-bind*",1)]),s[2]||(s[2]=l("** 表达式** 中，然后放在操作符“ | ”后面进行指示。"))]),s[4]||(s[4]=a(`<p>例如，在显示金额，给商品价格添加单位：</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">li</span><span style="color:#ABB2BF;">&gt;商品价格：{{item.price | filterPrice}}&lt;/</span><span style="color:#E06C75;">li</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">filters: { filterPrice (price) { return price ? (&#39;￥&#39; + price) : &#39;--&#39; } }</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">li</span><span style="color:#B392F0;">&gt;商品价格：{{item.price | filterPrice}}&lt;/</span><span style="color:#FFAB70;">li</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">filters: { filterPrice (price) { return price ? (&#39;￥&#39; + price) : &#39;--&#39; } }</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="如何保存页面的当前的状态" tabindex="-1">如何保存页面的当前的状态 <a class="header-anchor" href="#如何保存页面的当前的状态" aria-hidden="true">#</a></h2><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在 LocalStorage / SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。 <strong>优点：</strong></p><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><p><strong>缺点：</strong></p><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。 在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。 <strong>优点：</strong></p><ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul><p><strong>缺点：</strong></p><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><p><strong>优点：</strong></p><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><p><strong>缺点：</strong></p><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在 Vue 中，还可以是用 keep-alive 来缓存页面，当组件在 keep-alive 内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在 keep-alive 中的组件的状态将会被保留：</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">keep-alive</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">	&lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span></span>
<span class="line"><span style="color:#ABB2BF;">&lt;/kepp-alive&gt;</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">&lt;</span><span style="color:#FFAB70;">keep-alive</span><span style="color:#B392F0;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">	&lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span></span>
<span class="line"><span style="color:#B392F0;">&lt;/kepp-alive&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>router.js</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">  path: </span><span style="color:#98C379;">&#39;/&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  name: </span><span style="color:#98C379;">&#39;xxx&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  component: ()</span><span style="color:#C678DD;">=&gt;</span><span style="color:#61AFEF;">import</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;../src/views/xxx.vue&#39;</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#ABB2BF;">  meta:{</span></span>
<span class="line"><span style="color:#ABB2BF;">    keepAlive: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// 需要被缓存</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">},</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">{</span></span>
<span class="line"><span style="color:#B392F0;">  path</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&#39;/&#39;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  name</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&#39;xxx&#39;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  component</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> ()</span><span style="color:#F97583;">=&gt;import</span><span style="color:#B392F0;">(</span><span style="color:#FFAB70;">&#39;../src/views/xxx.vue&#39;</span><span style="color:#B392F0;">)</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  meta</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;">{</span></span>
<span class="line"><span style="color:#B392F0;">    keepAlive</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;"> </span><span style="color:#6B737C;">// 需要被缓存</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">}</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="常见的事件修饰符及其作用" tabindex="-1">常见的事件修饰符及其作用 <a class="header-anchor" href="#常见的事件修饰符及其作用" aria-hidden="true">#</a></h2><ul><li>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li><li>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</li><li>.self ：只会触发自己范围内的事件，不包含子元素；</li><li>.once ：只会触发一次。</li></ul><h2 id="v-if、v-show、v-html-的原理" tabindex="-1">v-if、v-show、v-html 的原理 <a class="header-anchor" href="#v-if、v-show、v-html-的原理" aria-hidden="true">#</a></h2><ul><li>v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染；</li><li>v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display；</li><li>v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHTML 为 v-html 的值。</li></ul><p>v-if 能够控制是否生成 vnode，也就间接控制了是否生成对应的 dom。当 v-if 为 true 时，会生成对应的 vnode，并生成对应的 dom 元素；当其为 false 时，不会生成对应的 vnode，自然不会生成任何的 dom 元素。 v-show 始终会生成 vnode，也就间接导致了始终生成 dom。它只是控制 dom 的 display 属性，当 v-show 为 true 时，不做任何处理；当其为 false 时，生成的 dom 的 display 属性为 none。 使用 v-if 可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用 v-show 可以保持树的稳定，但不能减少树的节点和渲染量。 因此，在实际开发中，显示状态变化频繁的情况下应该使用 v-show，以保持树的稳定；显示状态变化较少时应该使用 v-if，以减少树的节点和渲染量。</p><h2 id="data-为什么是一个函数而不是对象" tabindex="-1">data 为什么是一个函数而不是对象 <a class="header-anchor" href="#data-为什么是一个函数而不是对象" aria-hidden="true">#</a></h2><p>JavaScript 中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。 而在 Vue 中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。 所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的 data，也就是说每个组件都有自己的私有数据空间，<strong>它们各自维护自己的数据，不会干扰其他组件的正常运行。</strong></p><h2 id="vue-中封装的数组方法有哪些-其如何实现页面更新" tabindex="-1">Vue 中封装的数组方法有哪些，其如何实现页面更新 <a class="header-anchor" href="#vue-中封装的数组方法有哪些-其如何实现页面更新" aria-hidden="true">#</a></h2><p>在 Vue 中，对响应式处理利用的是 Object.defineProperty 对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行 hack，让 Vue 能监听到其中的变化。 push() pop() shift() unshift () splice() sort() reverse() 那 Vue 是如何实现让这些数组方法实现元素的实时更新的呢，下面是 Vue 中对这些方法的封装：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 缓存数组原型</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">arrayProto</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Array</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 实现 arrayMethods.__proto__ === Array.prototype</span></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">arrayMethods</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">create</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">arrayProto</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 需要进行功能拓展的方法</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">methodsToPatch</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;push&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;pop&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;shift&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;unshift&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;splice&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;sort&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#98C379;">&quot;reverse&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * Intercept mutating methods and emit events</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#E5C07B;">methodsToPatch</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">forEach</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">method</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 缓存原生数组方法</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">original</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">arrayProto</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">method</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">def</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">arrayMethods</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">method</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">mutator</span><span style="color:#ABB2BF;">(...</span><span style="color:#E06C75;font-style:italic;">args</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 执行并缓存原生数组功能</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">result</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">original</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">apply</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">args</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 响应式处理</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">ob</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">__ob__</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">inserted</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">switch</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">method</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#7F848E;font-style:italic;">// push、unshift会新增索引，所以要手动observer</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#C678DD;">case</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;push&quot;</span><span style="color:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#C678DD;">case</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;unshift&quot;</span><span style="color:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">inserted</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">args</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#C678DD;">break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#7F848E;font-style:italic;">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#C678DD;">case</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;splice&quot;</span><span style="color:#ABB2BF;">:</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E06C75;">inserted</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">args</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">slice</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#C678DD;">break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">inserted</span><span style="color:#ABB2BF;">) </span><span style="color:#E5C07B;">ob</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">observeArray</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">inserted</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 获取插入的值，并设置响应式监听</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// notify change</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">ob</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">dep</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">notify</span><span style="color:#ABB2BF;">(); </span><span style="color:#7F848E;font-style:italic;">// 通知依赖更新</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 返回原生数组方法的执行结果</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">result</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  });</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#6B737C;">// 缓存数组原型</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">arrayProto</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Array</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#6B737C;">// 实现 arrayMethods.__proto__ === Array.prototype</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">arrayMethods</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#B392F0;">.create(arrayProto);</span></span>
<span class="line"><span style="color:#6B737C;">// 需要进行功能拓展的方法</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">methodsToPatch</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> [</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;push&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;pop&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;shift&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;unshift&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;splice&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;sort&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#FFAB70;">&quot;reverse&quot;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C;">/**</span></span>
<span class="line"><span style="color:#6B737C;"> * Intercept mutating methods and emit events</span></span>
<span class="line"><span style="color:#6B737C;"> */</span></span>
<span class="line"><span style="color:#79B8FF;">methodsToPatch</span><span style="color:#B392F0;">.forEach(</span><span style="color:#F97583;">function</span><span style="color:#B392F0;"> (method) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 缓存原生数组方法</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">original</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> arrayProto[method];</span></span>
<span class="line"><span style="color:#B392F0;">  def(arrayMethods</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> method</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">function</span><span style="color:#B392F0;"> mutator(</span><span style="color:#F97583;">...</span><span style="color:#B392F0;">args) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 执行并缓存原生数组功能</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">result</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">original</span><span style="color:#B392F0;">.apply(</span><span style="color:#79B8FF;">this</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> args);</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 响应式处理</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">ob</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.__ob__;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> inserted;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">switch</span><span style="color:#B392F0;"> (method) {</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#6B737C;">// push、unshift会新增索引，所以要手动observer</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#F97583;">case</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;push&quot;</span><span style="color:#B392F0;">:</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#F97583;">case</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;unshift&quot;</span><span style="color:#B392F0;">:</span></span>
<span class="line"><span style="color:#B392F0;">        inserted </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> args;</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#F97583;">break</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#6B737C;">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span></span>
<span class="line"><span style="color:#B392F0;">      </span><span style="color:#F97583;">case</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;splice&quot;</span><span style="color:#B392F0;">:</span></span>
<span class="line"><span style="color:#B392F0;">        inserted </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">args</span><span style="color:#B392F0;">.slice(</span><span style="color:#F8F8F8;">2</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">        </span><span style="color:#F97583;">break</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    }</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">//</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (inserted) </span><span style="color:#79B8FF;">ob</span><span style="color:#B392F0;">.observeArray(inserted); </span><span style="color:#6B737C;">// 获取插入的值，并设置响应式监听</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// notify change</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">ob</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">dep</span><span style="color:#B392F0;">.notify(); </span><span style="color:#6B737C;">// 通知依赖更新</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 返回原生数组方法的执行结果</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> result;</span></span>
<span class="line"><span style="color:#B392F0;">  });</span></span>
<span class="line"><span style="color:#B392F0;">});</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的<strong>ob</strong>，也就是它的 Observer 对象，如果有新的值，就调用 observeArray 继续对新的值观察变化（也就是通过 target proto == arrayMethods 来改变了数组实例的型），然后手动调用 notify，通知渲染 watcher，执行 update。</p><h2 id="vue-单页应用与多页应用的区别" tabindex="-1">Vue 单页应用与多页应用的区别 <a class="header-anchor" href="#vue-单页应用与多页应用的区别" aria-hidden="true">#</a></h2><p><strong>概念：</strong></p><ul><li>SPA 单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次 js、css 等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA 多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载 js、css 等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><h2 id="vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" tabindex="-1">Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ <a class="header-anchor" href="#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" aria-hidden="true">#</a></h2><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。</p><h2 id="简述-mixin、extends-的覆盖逻辑" tabindex="-1">简述 mixin、extends 的覆盖逻辑 <a class="header-anchor" href="#简述-mixin、extends-的覆盖逻辑" aria-hidden="true">#</a></h2><p><strong>（1）mixin 和 extends</strong> mixin 和 extends 均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">_base</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">extends</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">parent</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">mergeOptions</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parent</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">extends</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">vm</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">mixins</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">l</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">mixins</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">l</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span><span style="color:#E06C75;">parent</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">mergeOptions</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parent</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">child</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">mixins</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">], </span><span style="color:#E06C75;">vm</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">!</span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">._base) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">.extends) {</span></span>
<span class="line"><span style="color:#B392F0;">    parent </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> mergeOptions(parent</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">.extends</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> vm);</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">.mixins) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">for</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> i </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">0</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> l </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">mixins</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">length</span><span style="color:#B392F0;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#B392F0;"> l; i</span><span style="color:#F97583;">++</span><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">      parent </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> mergeOptions(parent</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">child</span><span style="color:#B392F0;">.mixins[i]</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> vm);</span></span>
<span class="line"><span style="color:#B392F0;">    }</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h2 id="assets-和-static-的区别" tabindex="-1">assets 和 static 的区别 <a class="header-anchor" href="#assets-和-static-的区别" aria-hidden="true">#</a></h2><p><strong>相同点：</strong> assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong> assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h2 id="delete-和-vue-delete-删除数组的区别" tabindex="-1">delete 和 Vue.delete 删除数组的区别 <a class="header-anchor" href="#delete-和-vue-delete-删除数组的区别" aria-hidden="true">#</a></h2><ul><li>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</li><li>Vue.delete 直接删除了数组 改变了数组的键值。</li></ul><h2 id="什么是-mixin" tabindex="-1">什么是 mixin ？ <a class="header-anchor" href="#什么是-mixin" aria-hidden="true">#</a></h2><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h2 id="template-和-jsx-的有什么分别" tabindex="-1">template 和 jsx 的有什么分别？ <a class="header-anchor" href="#template-和-jsx-的有什么分别" aria-hidden="true">#</a></h2><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用 vue-loader 编译.vue 文件，内部依赖的 vue-template-compiler 模块，在 webpack 构建过程中，将 template 预编译成 render 函数。与 react 类似，在添加了 jsx 的语法糖解析器 babel-plugin-transform-vue-jsx 之后，就可以直接手写 render 函数。 所以，template 和 jsx 的都是 render 的一种表现形式，不同的是：JSX 相对于 template 而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h2 id="vue-初始化页面闪动问题" tabindex="-1">vue 初始化页面闪动问题 <a class="header-anchor" href="#vue-初始化页面闪动问题" aria-hidden="true">#</a></h2>`,63)),n("p",null,"使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于"+e(p.message)+"的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。 首先：在 css 里加上以下代码：",1),s[5]||(s[5]=a(`<div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">v</span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;">cloak</span><span style="color:#ABB2BF;">] {    display: </span><span style="color:#E06C75;">none</span><span style="color:#ABB2BF;">;}</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">[v</span><span style="color:#F97583;">-</span><span style="color:#B392F0;">cloak] {    display</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> none;}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果没有彻底解决问题，则在根元素加上 style=&quot;display: none;&quot; :style=&quot;{display: &#39;block&#39;}&quot;</p><h2 id="extend-有什么作用" tabindex="-1">extend 有什么作用 <a class="header-anchor" href="#extend-有什么作用" aria-hidden="true">#</a></h2><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 创建组件构造器</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">Component</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Vue</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">extend</span><span style="color:#ABB2BF;">({ </span><span style="color:#E06C75;">template</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;&lt;div&gt;test&lt;/div&gt;&quot;</span><span style="color:#ABB2BF;"> });</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 挂载到 #app 上new Component().$mount(&#39;#app&#39;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent({    created() {        console.log(1)    }})</span></span>
<span class="line"><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">SuperComponent</span><span style="color:#ABB2BF;">().</span><span style="color:#61AFEF;">$mount</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;#app&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#6B737C;">// 创建组件构造器</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> Component </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Vue</span><span style="color:#B392F0;">.extend({ template</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&quot;&lt;div&gt;test&lt;/div&gt;&quot;</span><span style="color:#B392F0;"> });</span></span>
<span class="line"><span style="color:#6B737C;">// 挂载到 #app 上new Component().$mount(&#39;#app&#39;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent({    created() {        console.log(1)    }})</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#B392F0;"> SuperComponent().$mount(</span><span style="color:#FFAB70;">&quot;#app&quot;</span><span style="color:#B392F0;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="mixin-和-mixins-区别" tabindex="-1">mixin 和 mixins 区别 <a class="header-anchor" href="#mixin-和-mixins-区别" aria-hidden="true">#</a></h2><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#E5C07B;">Vue</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">mixin</span><span style="color:#ABB2BF;">({</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">beforeCreate</span><span style="color:#ABB2BF;">() {        </span><span style="color:#7F848E;font-style:italic;">// ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    }})</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#79B8FF;">Vue</span><span style="color:#B392F0;">.mixin({</span></span>
<span class="line"><span style="color:#B392F0;">  beforeCreate() {        </span><span style="color:#6B737C;">// ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    }})</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。</p><p>mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p><h2 id="内置组件-transition" tabindex="-1">内置组件 Transition <a class="header-anchor" href="#内置组件-transition" aria-hidden="true">#</a></h2><blockquote><p>官网详细文档：<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noreferrer">https://cn.vuejs.org/v2/guide/transitions.html</a></p></blockquote><p><strong>时机</strong></p><p><code>Transition</code>组件会监控<code>slot</code>中<strong>唯一根元素</strong>的出现和消失，并会在其出现和消失时应用过渡效果 <code>Transition</code>不生成任何元素，只是为了生成过渡效果 具体的监听内容是：</p><ul><li>它会对新旧两个虚拟节点进行对比，如果旧节点被销毁，则应用消失效果，如果新节点是新增的，则应用进入效果</li><li>如果不是上述情况，则它会对比新旧节点，观察其<code>v-show</code>是否变化，<code>true-&gt;false</code>应用消失效果，<code>false-&gt;true</code>应用进入效果</li></ul><p><strong>流程</strong></p><blockquote><p>类名规则：</p><ol><li>如果<code>transition</code>上没有定义<code>name</code>，则类名为<code>v-xxxx</code></li><li>如果<code>transition</code>上定义了<code>name</code>，则类名为<code>\${name}-xxxx</code></li><li>如果指定了类名，直接使用指定的类名</li></ol></blockquote><blockquote><p>指定类名见：<a href="https://cn.vuejs.org/v2/guide/transitions.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D" target="_blank" rel="noreferrer">自定义过渡类名</a></p></blockquote><p><strong>1. 进入效果</strong></p><p><strong>2. 消失效果</strong></p><h2 id="过渡组" tabindex="-1">过渡组 <a class="header-anchor" href="#过渡组" aria-hidden="true">#</a></h2><p><code>Transision</code>可以监控其内部的<strong>单个 dom 元素</strong>的出现和消失，并为其附加样式</p><p>如果要监控一个 dom 列表，就需要使用<code>TransitionGroup</code>组件</p><p>它会对列表的新增元素应用<strong>进入效果</strong>，删除元素应用<strong>消失效果</strong>，对被移动的元素应用<code>v-move</code>样式</p><blockquote><p>被移动的元素之所以能够实现过渡效果，是因为<code>TransisionGroup</code>内部使用了 Flip 过渡方案</p></blockquote>`,25))])}const b=o(c,[["render",i]]);export{u as __pageData,b as default};
