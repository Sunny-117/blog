import{_ as a}from"./chunks/plugin-vue_export-helper.DlAUqK2U.js";import{c as i,o as s,X as l}from"./chunks/vendor-vueuse.XPft87tp.js";const v=JSON.parse('{"title":"keep-alive 与 LRU 算法","description":"","frontmatter":{},"headers":[],"relativePath":"vue/keep-alive-LRU.md","filePath":"vue/keep-alive-LRU.md","lastUpdated":1771466668000}'),p={name:"vue/keep-alive-LRU.md"};function t(n,e,k,h,r,d){return s(),i("div",null,e[0]||(e[0]=[l(`<h1 id="keep-alive-与-lru-算法" tabindex="-1">keep-alive 与 LRU 算法 <a class="header-anchor" href="#keep-alive-与-lru-算法" aria-label="Permalink to &quot;keep-alive 与 LRU 算法&quot;">​</a></h1><p>keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。</p><p>keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。</p><p>受 keep-alive 的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后</p><p>在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象</p><p>key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值</p><p>cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM</p><p>在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。</p><p>当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes dracula vitesse-black vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6272A4;--shiki-dark:#758575DD;">// keep-alive 内部的声明周期函数</span></span>
<span class="line"><span style="--shiki-light:#50FA7B;--shiki-dark:#80A665;">created</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;"> ()</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;"> {</span></span>
<span class="line"><span style="--shiki-light:#BD93F9;--shiki-light-font-style:italic;--shiki-dark:#C99076;--shiki-dark-font-style:inherit;">    this</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">.</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#BD976A;">cache</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;"> =</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#BD976A;"> Object</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">.</span><span style="--shiki-light:#50FA7B;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">(</span><span style="--shiki-light:#BD93F9;--shiki-dark:#CB7676;">null</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">)</span></span>
<span class="line"><span style="--shiki-light:#BD93F9;--shiki-light-font-style:italic;--shiki-dark:#C99076;--shiki-dark-font-style:inherit;">    this</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">.</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#BD976A;">keys</span><span style="--shiki-light:#FF79C6;--shiki-dark:#444444;"> =</span><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;"> []</span></span>
<span class="line"><span style="--shiki-light:#F8F8F2;--shiki-dark:#444444;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="keep-alive-中的生命周期哪些" tabindex="-1">keep-alive 中的生命周期哪些 <a class="header-anchor" href="#keep-alive-中的生命周期哪些" aria-label="Permalink to &quot;keep-alive 中的生命周期哪些&quot;">​</a></h2><p>keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p><h2 id="lru-缓存算法" tabindex="-1">LRU 缓存算法 <a class="header-anchor" href="#lru-缓存算法" aria-label="Permalink to &quot;LRU 缓存算法&quot;">​</a></h2><p>TODO</p>`,16)]))}const F=a(p,[["render",t]]);export{v as __pageData,F as default};
